{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"gpyrn Modelling stellar activity with Gaussian process regression networks gpyrn is a Python package implementing a GPRN framework for the analysis of RV datasets. A GPRN is a model for multi-output regression which exploits the structural properties of neural networks and the flexibility of Gaussian processes. The GPRN was originally proposed by Wilson et al. (2012) . Authors The gpyrn package was developed at IA , in the context of the PhD thesis of Jo\u00e3o Camacho, with contributions from Jo\u00e3o Faria and Pedro Viana. Cite If you use this package in your work, please cite the following publication (currently under review) @ARTICLE { gpyrn2022 , author = {{Camacho}, J.~D. and {Faria}, J.~P. and {Viana}, P.~T.~P.} , title = \"{Modelling stellar activity with Gaussian process regression networks}\" , journal = {arXiv e-prints} , keywords = {Astrophysics - Earth and Planetary Astrophysics, Astrophysics - Solar and Stellar Astrophysics} , year = 2022 , month = may , eid = {arXiv:2205.06627} , pages = {arXiv:2205.06627} , archivePrefix = {arXiv} , eprint = {2205.06627} , primaryClass = {astro-ph.EP} , adsurl = {https://ui.adsabs.harvard.edu/abs/2022arXiv220506627C} , adsnote = {Provided by the SAO/NASA Astrophysics Data System} } License Copyright 2022 Institute of Astrophysics and Space Sciences. Licensed under the MIT license (see LICENSE ).","title":"Welcome"},{"location":"#gpyrn","text":"Modelling stellar activity with Gaussian process regression networks gpyrn is a Python package implementing a GPRN framework for the analysis of RV datasets. A GPRN is a model for multi-output regression which exploits the structural properties of neural networks and the flexibility of Gaussian processes. The GPRN was originally proposed by Wilson et al. (2012) .","title":"gpyrn"},{"location":"#authors","text":"The gpyrn package was developed at IA , in the context of the PhD thesis of Jo\u00e3o Camacho, with contributions from Jo\u00e3o Faria and Pedro Viana.","title":"Authors"},{"location":"#cite","text":"If you use this package in your work, please cite the following publication (currently under review) @ARTICLE { gpyrn2022 , author = {{Camacho}, J.~D. and {Faria}, J.~P. and {Viana}, P.~T.~P.} , title = \"{Modelling stellar activity with Gaussian process regression networks}\" , journal = {arXiv e-prints} , keywords = {Astrophysics - Earth and Planetary Astrophysics, Astrophysics - Solar and Stellar Astrophysics} , year = 2022 , month = may , eid = {arXiv:2205.06627} , pages = {arXiv:2205.06627} , archivePrefix = {arXiv} , eprint = {2205.06627} , primaryClass = {astro-ph.EP} , adsurl = {https://ui.adsabs.harvard.edu/abs/2022arXiv220506627C} , adsnote = {Provided by the SAO/NASA Astrophysics Data System} }","title":"Cite"},{"location":"#license","text":"Copyright 2022 Institute of Astrophysics and Space Sciences. Licensed under the MIT license (see LICENSE ).","title":"License"},{"location":"benchmarks/","text":"TO DO We are still missing some benchmarks for the GPRN implementation. Hopefully they will be available soon.","title":"Benchmarks"},{"location":"getting_started/","text":"Using gpyrn should be simple if you are familiar with Python. Just import the package directly or each of the three sub-packages import gpyrn from gpyrn import meanfunc , covfunc , meanfield The covfunc package provides covariance functions (kernels) to be used for the GPRN nodes and weights. meanfunc provides the mean functions to use for a given dataset. Note that, in the GPRN model, the nodes and weights are independent GPs with mean zero; these mean functions will apply to the output datasets. The heavy-lifting is done by the mean-field approximation that is implemented in meanfield . As described in the examples , the typical use will be to instantiate a meanfield.inference object passing in the observed datasets, and then defining the GPRN components (nodes, weights, and means). So typically you would do something like # load data... # create an inference object gprn = meanfield . inference ( N_NODES , time_array , * outputs_and_errors ) # define GPRN components nodes = [ covfunc . ... ] weights = [ covfunc . ... ] means = [ meanfunc . ... ] jitters = [ ... ] gprn . set_components ( nodes , weights , means , jitters ) after which you can calculate gprn.ELBO or optimize the parameters with gprn.optimize() .","title":"Getting started"},{"location":"installation/","text":"Installing gpyrn is simple, as it depends on standard Python packages. Using pip The easiest way to install the latest version of gpyrn is using pip python -m pip install gpyrn From source An alternative installation method is to clone the GitHub repository and installing directly from source git clone https://github.com/iastro-pt/gpyrn.git cd gpyrn python setup.py install Where to go from here Once the package is installed, fell free to explore the getting started guide or go through one of the available examples . Continuous Integration The gpyrn package is built and tested under continuous integration, using GitHub actions. If the badges below are green, the installation process should go smoothly. Any issues can be reported here .","title":"Installation"},{"location":"installation/#using-pip","text":"The easiest way to install the latest version of gpyrn is using pip python -m pip install gpyrn","title":"Using pip"},{"location":"installation/#from-source","text":"An alternative installation method is to clone the GitHub repository and installing directly from source git clone https://github.com/iastro-pt/gpyrn.git cd gpyrn python setup.py install","title":"From source"},{"location":"installation/#where-to-go-from-here","text":"Once the package is installed, fell free to explore the getting started guide or go through one of the available examples . Continuous Integration The gpyrn package is built and tested under continuous integration, using GitHub actions. If the badges below are green, the installation process should go smoothly. Any issues can be reported here .","title":"Where to go from here"},{"location":"model_description/","text":"","title":"Model description"},{"location":"examples/","text":"Examples These are some examples on how to use gpyrn . We will be adding more in the near future. One dataset TODO: Several datasets","title":"Examples"},{"location":"examples/#examples","text":"These are some examples on how to use gpyrn . We will be adding more in the near future. One dataset TODO: Several datasets","title":"Examples"},{"location":"examples/one_dataset/","text":"import os os . environ [ 'JAX_PLATFORM_NAME' ] = 'cpu' Simple example with one simulated dataset This first example uses a very simple GPRN structure to fit a single simulated dataset. We will simulate data from a model that, while not being exactly a GPRN, encapsulates much of the same assumptions, making it even easier for the GPRN to match the data. First, we import some standard packages and the three main modules from gpyrn import numpy as np from scipy.stats import norm import matplotlib.pyplot as plt from gpyrn import covfunc , meanfunc , meanfield As you can probably guess, covfunc provides covariance functions (kernels) to be used for the GPRN nodes and weights. meanfunc provides the mean functions for a given dataset. Note that, in the GPRN model, the nodes and weights are GPs with mean zero ; the mean functions apply to the output datasets. Let's simulate some data, using a fixed random seed to guarantee reproducible results np . random . seed ( 43 ) Our simulation is simple. We start by generating 45 times , randomly distributed between 10 and 60 (in arbitrary units). The single output dataset is then created by the multiplication of a sinusoidal function and a quadratic. The truth dictionary stores the true parameters for each function. truth = { 'A' : 1.5 , 'P' : 13.5 , '\u03a6' : 0.0 , 'c0' : 2.5 , 'c1' : 0.02 , 'c2' : 0.01 , 'j' : 0.5 , } t = np . sort ( np . random . uniform ( 10 , 60 , 45 )) y = truth [ 'A' ] * np . sin ( 2 * np . pi * t / truth [ 'P' ] + truth [ '\u03a6' ]) y *= np . polyval ([ truth [ 'c2' ], truth [ 'c1' ], truth [ 'c0' ]], t ) To simulate individual uncertainties for each point, we draw from a uniform distribution between 2 and 5 (again, in arbitrary units). These are then used, together with a \"jitter\" value, to add Gaussian noise to the output dataset. yerr = np . random . uniform ( 2 , 5 , size = t . size ) y += norm ( 0 , np . hypot ( truth [ 'j' ], yerr )) . rvs () Let's plot the data and the components we used to create it tplot = np . linspace ( t [ 0 ], t [ - 1 ], 1000 ) sine = truth [ 'A' ] * np . sin ( 2 * np . pi * tplot / truth [ 'P' ] + truth [ '\u03a6' ]) quad = np . polyval ([ truth [ 'c2' ], truth [ 'c1' ], truth [ 'c0' ]], tplot ) fig , ax = plt . subplots ( constrained_layout = True ) ax . plot ( tplot , sine , label = 'sine (latent)' ) ax . plot ( tplot , quad , label = 'quad (latent)' ) ax . errorbar ( t , y , yerr , fmt = 'o' , label = 'observed' ) ax . set ( xlabel = 't' , ylabel = 'y' ) ax . legend (); We now build the GPRN model by specifying its components. First, we create an inference object, passing in the number of nodes we will consider and the simulated data. gprn = meanfield . inference ( 1 , t , y , yerr ) Next, we define the node and weight kernels. We use a periodic kernel (also sometimes called exponential sine squared) for the node and a squared exponential for the weight, providing initial values for their hyperparameters. The mean function is just a constant, set initially to 0, while the jitter starts at 0.1. nodes = covfunc . Periodic ( 1 , 13 , 1 ) weights = covfunc . SquaredExponential ( 1 , 50 ) means = meanfunc . Constant ( 0 ) jitters = 0.1 gprn . set_components ( nodes , weights , means , jitters ) We can use the plot_prediction method to see what the GPRN prediction looks like with these initial parameters. fig , axs = gprn . plot_prediction ( title = 'starting values for parameters' ) Let's optimize the parameters, by maximizing the ELBO. Note By default, gpyrn uses the Nelder-Mead method with scipy.optimize.minimize . This can be changed by passing in keyword arguments which go directly into minimize . print ( 'initial ELBO:' , gprn . ELBO ) res = gprn . optimize () initial ELBO: -267.0695853949569 ELBO=-138.69 (took 10.20 ms) Info When running the code above you will see the ELBO value changing and information on how much time each iteration of the optimizer took. The value shown above is just the last iteration. There was quite a large improvement from the initial value for the ELBO. Let's see how the parameters of the GPRN components changed print ( 'node:' , gprn . nodes ) print ( 'weight:' , gprn . weights ) print ( 'mean:' , gprn . means ) print ( 'jitter:' , gprn . jitters ) node: [Periodic(theta=16.00434731678536, P=13.628998982156476, ell=5.286973641067731)] weight: [SquaredExponential(theta=6.391768795740714, ell=39.555951182946636)] mean: [Constant(-0.029692005846167595)] jitter: [-0.00803944] And now we can plot again the GPRN prediction, together with the actual components we used to generate the data. fig , axs = gprn . plot_prediction ( title = 'after optimization' ) axs [ 'd1' ] . plot ( tplot , quad , label = 'quad (latent)' ) axs [ 'd1' ] . legend ( loc = 2 ) axs [ 'node' ] . plot ( tplot , sine , label = 'sine (latent)' ) axs [ 'node' ] . legend ( loc = 2 );","title":"One dataset"},{"location":"examples/one_dataset/#simple-example-with-one-simulated-dataset","text":"This first example uses a very simple GPRN structure to fit a single simulated dataset. We will simulate data from a model that, while not being exactly a GPRN, encapsulates much of the same assumptions, making it even easier for the GPRN to match the data. First, we import some standard packages and the three main modules from gpyrn import numpy as np from scipy.stats import norm import matplotlib.pyplot as plt from gpyrn import covfunc , meanfunc , meanfield As you can probably guess, covfunc provides covariance functions (kernels) to be used for the GPRN nodes and weights. meanfunc provides the mean functions for a given dataset. Note that, in the GPRN model, the nodes and weights are GPs with mean zero ; the mean functions apply to the output datasets. Let's simulate some data, using a fixed random seed to guarantee reproducible results np . random . seed ( 43 ) Our simulation is simple. We start by generating 45 times , randomly distributed between 10 and 60 (in arbitrary units). The single output dataset is then created by the multiplication of a sinusoidal function and a quadratic. The truth dictionary stores the true parameters for each function. truth = { 'A' : 1.5 , 'P' : 13.5 , '\u03a6' : 0.0 , 'c0' : 2.5 , 'c1' : 0.02 , 'c2' : 0.01 , 'j' : 0.5 , } t = np . sort ( np . random . uniform ( 10 , 60 , 45 )) y = truth [ 'A' ] * np . sin ( 2 * np . pi * t / truth [ 'P' ] + truth [ '\u03a6' ]) y *= np . polyval ([ truth [ 'c2' ], truth [ 'c1' ], truth [ 'c0' ]], t ) To simulate individual uncertainties for each point, we draw from a uniform distribution between 2 and 5 (again, in arbitrary units). These are then used, together with a \"jitter\" value, to add Gaussian noise to the output dataset. yerr = np . random . uniform ( 2 , 5 , size = t . size ) y += norm ( 0 , np . hypot ( truth [ 'j' ], yerr )) . rvs () Let's plot the data and the components we used to create it tplot = np . linspace ( t [ 0 ], t [ - 1 ], 1000 ) sine = truth [ 'A' ] * np . sin ( 2 * np . pi * tplot / truth [ 'P' ] + truth [ '\u03a6' ]) quad = np . polyval ([ truth [ 'c2' ], truth [ 'c1' ], truth [ 'c0' ]], tplot ) fig , ax = plt . subplots ( constrained_layout = True ) ax . plot ( tplot , sine , label = 'sine (latent)' ) ax . plot ( tplot , quad , label = 'quad (latent)' ) ax . errorbar ( t , y , yerr , fmt = 'o' , label = 'observed' ) ax . set ( xlabel = 't' , ylabel = 'y' ) ax . legend (); We now build the GPRN model by specifying its components. First, we create an inference object, passing in the number of nodes we will consider and the simulated data. gprn = meanfield . inference ( 1 , t , y , yerr ) Next, we define the node and weight kernels. We use a periodic kernel (also sometimes called exponential sine squared) for the node and a squared exponential for the weight, providing initial values for their hyperparameters. The mean function is just a constant, set initially to 0, while the jitter starts at 0.1. nodes = covfunc . Periodic ( 1 , 13 , 1 ) weights = covfunc . SquaredExponential ( 1 , 50 ) means = meanfunc . Constant ( 0 ) jitters = 0.1 gprn . set_components ( nodes , weights , means , jitters ) We can use the plot_prediction method to see what the GPRN prediction looks like with these initial parameters. fig , axs = gprn . plot_prediction ( title = 'starting values for parameters' ) Let's optimize the parameters, by maximizing the ELBO. Note By default, gpyrn uses the Nelder-Mead method with scipy.optimize.minimize . This can be changed by passing in keyword arguments which go directly into minimize . print ( 'initial ELBO:' , gprn . ELBO ) res = gprn . optimize () initial ELBO: -267.0695853949569 ELBO=-138.69 (took 10.20 ms) Info When running the code above you will see the ELBO value changing and information on how much time each iteration of the optimizer took. The value shown above is just the last iteration. There was quite a large improvement from the initial value for the ELBO. Let's see how the parameters of the GPRN components changed print ( 'node:' , gprn . nodes ) print ( 'weight:' , gprn . weights ) print ( 'mean:' , gprn . means ) print ( 'jitter:' , gprn . jitters ) node: [Periodic(theta=16.00434731678536, P=13.628998982156476, ell=5.286973641067731)] weight: [SquaredExponential(theta=6.391768795740714, ell=39.555951182946636)] mean: [Constant(-0.029692005846167595)] jitter: [-0.00803944] And now we can plot again the GPRN prediction, together with the actual components we used to generate the data. fig , axs = gprn . plot_prediction ( title = 'after optimization' ) axs [ 'd1' ] . plot ( tplot , quad , label = 'quad (latent)' ) axs [ 'd1' ] . legend ( loc = 2 ) axs [ 'node' ] . plot ( tplot , sine , label = 'sine (latent)' ) axs [ 'node' ] . legend ( loc = 2 );","title":"Simple example with one simulated dataset"},{"location":"examples/several_datasets/","text":"Simple example with one simulated dataset import numpy as np import matplotlib.pyplot as plt from gpyrn import meanfield , covfunc , meanfunc","title":"Several datasets"},{"location":"examples/several_datasets/#simple-example-with-one-simulated-dataset","text":"import numpy as np import matplotlib.pyplot as plt from gpyrn import meanfield , covfunc , meanfunc","title":"Simple example with one simulated dataset"},{"location":"reference/covfunc/","text":"This module provides covariance functions for the nodes and weights of the GPRN. covFunction ( * args ) Base class for covariance functions (kernels) used for nodes and weights in the GPRN. Sum Bases: _operator Sum of two covariance functions Multiplication Bases: _operator Product of two covariance functions Constant ( c ) Bases: covFunction This kernel returns the square of its constant argument c $$ K_{ij} = c^2 $$ Parameters: Name Type Description Default c float Constant value required WhiteNoise ( w ) Bases: covFunction White noise (diagonal) kernel $$ K_{ij} = w^2 \\, \\delta_{ij} $$ Parameters: Name Type Description Default w float White noise amplitude required SquaredExponential ( theta , ell ) Bases: covFunction Squared Exponential kernel, also known as radial basis function $$ K_{ij} = \\theta^2 \\, \\exp \\left[ - \\frac{(t_i - t_j)^2}{2 \\ell^2} \\right] $$ Parameters: Name Type Description Default theta float Amplitude required ell float Length-scale required Periodic ( theta , P , ell ) Bases: covFunction Periodic kernel, also known as the exponential sine squared $$ K_{ij} = \\theta^2 \\, \\exp \\left[ - \\frac{2 \\sin^2 \\left( \\frac{\\pi (t_i - t_j)}{P} \\right)}{\\ell^2} \\right] $$ Parameters: Name Type Description Default theta float Amplitude required P float Period required ell float Lenght scale required Parameterization Note that the periodic kernel is sometimes parameterized differently, namely using \\(\\Gamma = 2/\\ell^2\\) . QuasiPeriodic ( theta , elle , P , ellp ) Bases: covFunction This kernel is the product between the periodic kernel and the squared exponential kernel, and is commonly known as the quasi-periodic kernel $$ K_{ij} = \\theta^2 \\, \\exp \\left[ - \\frac{(t_i - t_j)^2}{2 \\ell_e^2} - \\frac{2 \\sin^2 \\left( \\frac{\\pi (t_i - t_j)}{P} \\right)}{\\ell_p^2} \\right] $$ Parameters: Name Type Description Default theta float Amplitude required elle float Evolutionary length scale required P float Kernel periodicity required ellp float Length scale of the periodic component required Info The QuasiPeriodic kernel is implemented on its own for convenience, but it is exactly equivalent to the product of a SquaredExponential and a Periodic kernel with the same parameters. RationalQuadratic ( theta , alpha , ell ) Bases: covFunction The rational quadratic kernel $$ $$ Parameters: Name Type Description Default theta float Amplitude of the kernel required alpha float Amplitude of large and small scale variations required ell float Characteristic lenght scale to define the kernel \"smoothness\" required RQP ( theta , alpha , elle , P , ellp ) Bases: covFunction Product between the periodic kernel and the rational quadratic kernel that we call RQP kernel. Parameters: Name Type Description Default theta float Amplitude required alpha float Alpha of the rational quadratic kernel required elle float Aperiodic length scale required P float Periodic repetitions of the kernel required ellp float Periodic length scale required Cosine ( theta , P ) Bases: covFunction the cosine kernel Parameters: Name Type Description Default theta float Amplitude required P float Period required Exponential ( theta , ell ) Bases: covFunction The exponential kernel $$ K_{ij} = \\theta^2 \\, \\exp \\left( - \\frac{|t_i - t_j|}{\\ell} \\right) $$ Parameters: Name Type Description Default theta float Amplitude required ell float Characteristic lenght scale required Matern32 ( theta , ell ) Bases: covFunction the Matern 3/2 kernel. This kernel arise when setting v=3/2 in the matern family of kernels Parameters: Name Type Description Default theta float Amplitude required ell float Characteristic lenght scale required Matern52 ( theta , ell ) Bases: covFunction the Matern 5/2 kernel. This kernel arise when setting v=5/2 in the matern family of kernels Parameters: Name Type Description Default theta float Amplitude required ell float Characteristic lenght scale required Linear ( c ) Bases: covFunction the Linear kernel Parameters: Name Type Description Default c Constant required GammaExp ( theta , gamma , l ) Bases: covFunction the gamma-exponential kernel Parameters: Name Type Description Default theta Amplitude required gamma Shape parameter ( 0 < gamma <= 2) required l Lenght scale required Polynomial ( theta , a , b , c ) Bases: covFunction the polynomial kernel Parameters: Name Type Description Default theta Amplitude ??? required a Real value > 0 required b Real value >= 0 required c Integer value required wn White noise amplitude required Piecewise ( eta ) Bases: covFunction third-order piecewise polynomial kernel Parameters: Name Type Description Default eta float required Paciorek ( amplitude , ell_1 , ell_2 ) Bases: covFunction Definition of the modified Paciorek's kernel (stationary version). Parameters: Name Type Description Default amplitude float required ell_1 float required ell_2 float required NewPeriodic ( amplitude , alpha2 , P , l ) Bases: covFunction Definition of a new periodic kernel derived from mapping the rational quadratic kernel to the 2D space u(x) = (cos x, sin x) Parameters: Name Type Description Default amplitude float required alpha2 float required P float required l float required QuasiNewPeriodic ( amplitude , alpha2 , ell_e , P , ell_p ) Bases: covFunction Definition of a new quasi-periodic kernel. Derived from mapping the rational quadratic kernel to the 2D space u(x) = (cos x, sin x) and multiplying it by a squared exponential kernel Parameters: Name Type Description Default amplitude float required alpha2 float required ell_e float required P float required ell_p float required NewRQP ( amplitude , alpha1 , alpha2 , ell_e , P , ell_p ) Bases: covFunction Definition of a new quasi-periodic kernel. Derived from mapping the rational quadratic kernel to the 2D space u(x) = (cos x, sin x) and multiplying it by a rational quadratic kernel Parameters: Name Type Description Default amplitude float required alpha1 float required ell_e float required P float required ell_p float required alpha2 float required HarmonicPeriodic ( N , amplitude , P , ell ) Bases: covFunction Definition of a periodic kernel that models a periodic signal with a N number of harmonics. Obtained by mapping the squared exponetial with the Lagrange trigonometric identities Parameters: Name Type Description Default N int required amplitude float required P float required ell float required QuasiHarmonicPeriodic ( N , amplitude , ell_e , P , ell_p ) Bases: covFunction Definition of a quasi-periodic kernel that models a periodic signals with a N number of harmonics. Comes from the multiplication of the squared exponential by the HarmonicPeriodic Parameters: Name Type Description Default N int required amplitude float required ell_e float required P float required ell_p float required CosPeriodic ( amplitude , P , ell ) Bases: covFunction Periodic kernel derived by mapping the squared exponential kernel into thw 2D space u(t) = [cos(t + phi), sin(t + phi)] SPOILER ALERT: If you do the math the phi terms disappear Parameters: Name Type Description Default amplitude float required P float required ell_p float required phi float required QuasiCosPeriodic ( amplitude , ell_e , P , ell_p ) Bases: covFunction This kernel is the product between the cosPeriodic kernel and the squared exponential kernel, it is just another the quasi-periodic kernel. Parameters: Name Type Description Default amplitude float required ell_e float required ell_p float required P float required","title":"covfunc"},{"location":"reference/covfunc/#gpyrn.covfunc.covFunction","text":"Base class for covariance functions (kernels) used for nodes and weights in the GPRN.","title":"covFunction"},{"location":"reference/covfunc/#gpyrn.covfunc.Sum","text":"Bases: _operator Sum of two covariance functions","title":"Sum"},{"location":"reference/covfunc/#gpyrn.covfunc.Multiplication","text":"Bases: _operator Product of two covariance functions","title":"Multiplication"},{"location":"reference/covfunc/#gpyrn.covfunc.Constant","text":"Bases: covFunction This kernel returns the square of its constant argument c $$ K_{ij} = c^2 $$ Parameters: Name Type Description Default c float Constant value required","title":"Constant"},{"location":"reference/covfunc/#gpyrn.covfunc.WhiteNoise","text":"Bases: covFunction White noise (diagonal) kernel $$ K_{ij} = w^2 \\, \\delta_{ij} $$ Parameters: Name Type Description Default w float White noise amplitude required","title":"WhiteNoise"},{"location":"reference/covfunc/#gpyrn.covfunc.SquaredExponential","text":"Bases: covFunction Squared Exponential kernel, also known as radial basis function $$ K_{ij} = \\theta^2 \\, \\exp \\left[ - \\frac{(t_i - t_j)^2}{2 \\ell^2} \\right] $$ Parameters: Name Type Description Default theta float Amplitude required ell float Length-scale required","title":"SquaredExponential"},{"location":"reference/covfunc/#gpyrn.covfunc.Periodic","text":"Bases: covFunction Periodic kernel, also known as the exponential sine squared $$ K_{ij} = \\theta^2 \\, \\exp \\left[ - \\frac{2 \\sin^2 \\left( \\frac{\\pi (t_i - t_j)}{P} \\right)}{\\ell^2} \\right] $$ Parameters: Name Type Description Default theta float Amplitude required P float Period required ell float Lenght scale required Parameterization Note that the periodic kernel is sometimes parameterized differently, namely using \\(\\Gamma = 2/\\ell^2\\) .","title":"Periodic"},{"location":"reference/covfunc/#gpyrn.covfunc.QuasiPeriodic","text":"Bases: covFunction This kernel is the product between the periodic kernel and the squared exponential kernel, and is commonly known as the quasi-periodic kernel $$ K_{ij} = \\theta^2 \\, \\exp \\left[ - \\frac{(t_i - t_j)^2}{2 \\ell_e^2} - \\frac{2 \\sin^2 \\left( \\frac{\\pi (t_i - t_j)}{P} \\right)}{\\ell_p^2} \\right] $$ Parameters: Name Type Description Default theta float Amplitude required elle float Evolutionary length scale required P float Kernel periodicity required ellp float Length scale of the periodic component required Info The QuasiPeriodic kernel is implemented on its own for convenience, but it is exactly equivalent to the product of a SquaredExponential and a Periodic kernel with the same parameters.","title":"QuasiPeriodic"},{"location":"reference/covfunc/#gpyrn.covfunc.RationalQuadratic","text":"Bases: covFunction The rational quadratic kernel $$ $$ Parameters: Name Type Description Default theta float Amplitude of the kernel required alpha float Amplitude of large and small scale variations required ell float Characteristic lenght scale to define the kernel \"smoothness\" required","title":"RationalQuadratic"},{"location":"reference/covfunc/#gpyrn.covfunc.RQP","text":"Bases: covFunction Product between the periodic kernel and the rational quadratic kernel that we call RQP kernel. Parameters: Name Type Description Default theta float Amplitude required alpha float Alpha of the rational quadratic kernel required elle float Aperiodic length scale required P float Periodic repetitions of the kernel required ellp float Periodic length scale required","title":"RQP"},{"location":"reference/covfunc/#gpyrn.covfunc.Cosine","text":"Bases: covFunction the cosine kernel Parameters: Name Type Description Default theta float Amplitude required P float Period required","title":"Cosine"},{"location":"reference/covfunc/#gpyrn.covfunc.Exponential","text":"Bases: covFunction The exponential kernel $$ K_{ij} = \\theta^2 \\, \\exp \\left( - \\frac{|t_i - t_j|}{\\ell} \\right) $$ Parameters: Name Type Description Default theta float Amplitude required ell float Characteristic lenght scale required","title":"Exponential"},{"location":"reference/covfunc/#gpyrn.covfunc.Matern32","text":"Bases: covFunction the Matern 3/2 kernel. This kernel arise when setting v=3/2 in the matern family of kernels Parameters: Name Type Description Default theta float Amplitude required ell float Characteristic lenght scale required","title":"Matern32"},{"location":"reference/covfunc/#gpyrn.covfunc.Matern52","text":"Bases: covFunction the Matern 5/2 kernel. This kernel arise when setting v=5/2 in the matern family of kernels Parameters: Name Type Description Default theta float Amplitude required ell float Characteristic lenght scale required","title":"Matern52"},{"location":"reference/covfunc/#gpyrn.covfunc.Linear","text":"Bases: covFunction the Linear kernel Parameters: Name Type Description Default c Constant required","title":"Linear"},{"location":"reference/covfunc/#gpyrn.covfunc.GammaExp","text":"Bases: covFunction the gamma-exponential kernel Parameters: Name Type Description Default theta Amplitude required gamma Shape parameter ( 0 < gamma <= 2) required l Lenght scale required","title":"GammaExp"},{"location":"reference/covfunc/#gpyrn.covfunc.Polynomial","text":"Bases: covFunction the polynomial kernel Parameters: Name Type Description Default theta Amplitude ??? required a Real value > 0 required b Real value >= 0 required c Integer value required wn White noise amplitude required","title":"Polynomial"},{"location":"reference/covfunc/#gpyrn.covfunc.Piecewise","text":"Bases: covFunction third-order piecewise polynomial kernel Parameters: Name Type Description Default eta float required","title":"Piecewise"},{"location":"reference/covfunc/#gpyrn.covfunc.Paciorek","text":"Bases: covFunction Definition of the modified Paciorek's kernel (stationary version). Parameters: Name Type Description Default amplitude float required ell_1 float required ell_2 float required","title":"Paciorek"},{"location":"reference/covfunc/#gpyrn.covfunc.NewPeriodic","text":"Bases: covFunction Definition of a new periodic kernel derived from mapping the rational quadratic kernel to the 2D space u(x) = (cos x, sin x) Parameters: Name Type Description Default amplitude float required alpha2 float required P float required l float required","title":"NewPeriodic"},{"location":"reference/covfunc/#gpyrn.covfunc.QuasiNewPeriodic","text":"Bases: covFunction Definition of a new quasi-periodic kernel. Derived from mapping the rational quadratic kernel to the 2D space u(x) = (cos x, sin x) and multiplying it by a squared exponential kernel Parameters: Name Type Description Default amplitude float required alpha2 float required ell_e float required P float required ell_p float required","title":"QuasiNewPeriodic"},{"location":"reference/covfunc/#gpyrn.covfunc.NewRQP","text":"Bases: covFunction Definition of a new quasi-periodic kernel. Derived from mapping the rational quadratic kernel to the 2D space u(x) = (cos x, sin x) and multiplying it by a rational quadratic kernel Parameters: Name Type Description Default amplitude float required alpha1 float required ell_e float required P float required ell_p float required alpha2 float required","title":"NewRQP"},{"location":"reference/covfunc/#gpyrn.covfunc.HarmonicPeriodic","text":"Bases: covFunction Definition of a periodic kernel that models a periodic signal with a N number of harmonics. Obtained by mapping the squared exponetial with the Lagrange trigonometric identities Parameters: Name Type Description Default N int required amplitude float required P float required ell float required","title":"HarmonicPeriodic"},{"location":"reference/covfunc/#gpyrn.covfunc.QuasiHarmonicPeriodic","text":"Bases: covFunction Definition of a quasi-periodic kernel that models a periodic signals with a N number of harmonics. Comes from the multiplication of the squared exponential by the HarmonicPeriodic Parameters: Name Type Description Default N int required amplitude float required ell_e float required P float required ell_p float required","title":"QuasiHarmonicPeriodic"},{"location":"reference/covfunc/#gpyrn.covfunc.CosPeriodic","text":"Bases: covFunction Periodic kernel derived by mapping the squared exponential kernel into thw 2D space u(t) = [cos(t + phi), sin(t + phi)] SPOILER ALERT: If you do the math the phi terms disappear Parameters: Name Type Description Default amplitude float required P float required ell_p float required phi float required","title":"CosPeriodic"},{"location":"reference/covfunc/#gpyrn.covfunc.QuasiCosPeriodic","text":"Bases: covFunction This kernel is the product between the cosPeriodic kernel and the squared exponential kernel, it is just another the quasi-periodic kernel. Parameters: Name Type Description Default amplitude float required ell_e float required ell_p float required P float required","title":"QuasiCosPeriodic"},{"location":"reference/meanfunc/","text":"This module provides mean functions for the outputs of the GPRN. Each class derives from meanFunction and can be added or multiplied to other meanFunction instances. meanFunction ( * pars ) Base class for mean functions Sum ( m1 , m2 ) Bases: meanFunction Sum of two mean functions Product ( m1 , m2 ) Bases: meanFunction Product of two mean functions Constant ( c ) Bases: meanFunction A constant mean function Parameters: Name Type Description Default c float The constant value of the mean function required MultiConstant ( offsets , obsid , time ) Bases: meanFunction Contant mean function for multiple instruments Parameters: Name Type Description Default offsets np . ndarray Values of the between-instrument offsets and the average value of the last instrument: [off_1, off_2, ..., avg_n] Offsets are relative to the last instrument. required obsid np . ndarray Indices of observations corresponding to each instrument. These should be one-based: [1, 1, ..., 2, 2, 2, ..., 3] required time np . ndarray Observed times. Should be the same size as obsid . required Linear ( slope , intercept ) Bases: meanFunction A linear mean function, using the mean time as reference m(t) = slope * (t - mean(t)) + intercept Parameters: Name Type Description Default slope float The slope of the linear function required intercept float The intercept, using mean(t) as reference required Parabola ( quad , slope , intercept ) Bases: meanFunction A 2nd degree polynomial mean function m(t) = quad * t\u00b2 + slope * t + intercept Parameters: Name Type Description Default quad float The quadratic term required slope float The linear term required intercept float The intercept required Cubic ( cub , quad , slope , intercept ) Bases: meanFunction A 3rd degree polynomial mean function m(t) = cub * t\u00b3 + quad * t\u00b2 + slope * t + intercept Parameters: Name Type Description Default cub float The cubic term required quad float The quadratic term required slope float The linear term required intercept float The intercept required Sine ( amplitude , period , phase ) Bases: meanFunction A sinusoidal mean function m(t) = amplitude * sin(2*pi*t/P + phase) Parameters: Name Type Description Default amplitude float The amplitude of the sinusoidal function required period float The period of the sinusoidal function required phase float The phase of the sinusoidal function required","title":"meanfunc"},{"location":"reference/meanfunc/#gpyrn.meanfunc.meanFunction","text":"Base class for mean functions","title":"meanFunction"},{"location":"reference/meanfunc/#gpyrn.meanfunc.Sum","text":"Bases: meanFunction Sum of two mean functions","title":"Sum"},{"location":"reference/meanfunc/#gpyrn.meanfunc.Product","text":"Bases: meanFunction Product of two mean functions","title":"Product"},{"location":"reference/meanfunc/#gpyrn.meanfunc.Constant","text":"Bases: meanFunction A constant mean function Parameters: Name Type Description Default c float The constant value of the mean function required","title":"Constant"},{"location":"reference/meanfunc/#gpyrn.meanfunc.MultiConstant","text":"Bases: meanFunction Contant mean function for multiple instruments Parameters: Name Type Description Default offsets np . ndarray Values of the between-instrument offsets and the average value of the last instrument: [off_1, off_2, ..., avg_n] Offsets are relative to the last instrument. required obsid np . ndarray Indices of observations corresponding to each instrument. These should be one-based: [1, 1, ..., 2, 2, 2, ..., 3] required time np . ndarray Observed times. Should be the same size as obsid . required","title":"MultiConstant"},{"location":"reference/meanfunc/#gpyrn.meanfunc.Linear","text":"Bases: meanFunction A linear mean function, using the mean time as reference m(t) = slope * (t - mean(t)) + intercept Parameters: Name Type Description Default slope float The slope of the linear function required intercept float The intercept, using mean(t) as reference required","title":"Linear"},{"location":"reference/meanfunc/#gpyrn.meanfunc.Parabola","text":"Bases: meanFunction A 2nd degree polynomial mean function m(t) = quad * t\u00b2 + slope * t + intercept Parameters: Name Type Description Default quad float The quadratic term required slope float The linear term required intercept float The intercept required","title":"Parabola"},{"location":"reference/meanfunc/#gpyrn.meanfunc.Cubic","text":"Bases: meanFunction A 3rd degree polynomial mean function m(t) = cub * t\u00b3 + quad * t\u00b2 + slope * t + intercept Parameters: Name Type Description Default cub float The cubic term required quad float The quadratic term required slope float The linear term required intercept float The intercept required","title":"Cubic"},{"location":"reference/meanfunc/#gpyrn.meanfunc.Sine","text":"Bases: meanFunction A sinusoidal mean function m(t) = amplitude * sin(2*pi*t/P + phase) Parameters: Name Type Description Default amplitude float The amplitude of the sinusoidal function required period float The period of the sinusoidal function required phase float The phase of the sinusoidal function required","title":"Sine"}]}